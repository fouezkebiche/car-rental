







// [Folder] controllers








// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\controllers\authController.ts
import { Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import User, { IUser } from '../models/User';
import { validationResult } from 'express-validator';
import { sendRegistrationPendingEmail } from '../services/emailService'; // Import new email function

export const register = async (req: Request, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { name, email, password, phone, role } = req.body;

  try {
    // Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'Email already in use' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Set status to 'pending' for owners, 'active' for customers
    const status = role === 'owner' ? 'pending' : 'active';

    // Create user
    const user = new User({
      name,
      email,
      password: hashedPassword,
      phone,
      role,
      status,
      joinDate: new Date(),
    });

    await user.save();

    // Send registration pending email for owners
    if (role === 'owner') {
      await sendRegistrationPendingEmail({ to: email, userName: name });
      return res.status(201).json({
        message: 'Registration successful. Your account is pending admin approval. You will receive an email once your account is approved.',
      });
    }

    // Generate JWT for customers
    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET as string,
      { expiresIn: '1d' }
    );

    res.status(201).json({
      token,
      user: {
        id: user._id,
        name,
        email,
        role,
        status,
        phone: user.phone,
        joinDate: user.joinDate,
      },
    });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const login = async (req: Request, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, password } = req.body;

  try {
    // Find user
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Check status for owners
    if (user.role === 'owner' && user.status === 'pending') {
      return res.status(403).json({ message: 'Account awaiting admin approval' });
    }

    // Check password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    // Generate JWT
    const token = jwt.sign(
      { userId: user._id, role: user.role },
      process.env.JWT_SECRET as string,
      { expiresIn: '1d' }
    );

    res.json({
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        status: user.status,
        phone: user.phone,
        joinDate: user.joinDate,
      },
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\controllers\bookingController.ts
import { Request, Response } from 'express';
import Booking, { IBooking } from '../models/Booking';
import Car from '../models/Car';
import User from '../models/User';
import { AuthRequest } from '../middleware/authMiddleware';
import { validationResult } from 'express-validator';
import { sendBookingStatusEmail } from '../services/emailService';

export const createBooking = async (req: AuthRequest, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { carId, startDate, endDate, pickupLocation, dropoffLocation, additionalServices, paymentMethod } = req.body;

  try {
    const car = await Car.findById(carId);
    if (!car || !car.available || car.status !== 'approved') {
      return res.status(400).json({ message: 'Car not available for booking' });
    }

    // Check for overlapping bookings
    const overlappingBooking = await Booking.findOne({
      carId,
      status: { $in: ['pending', 'confirmed'] },
      $or: [
        { startDate: { $lte: new Date(endDate) }, endDate: { $gte: new Date(startDate) } },
      ],
    });
    if (overlappingBooking) {
      return res.status(400).json({ message: 'Car is already booked for the selected dates' });
    }

    const days = Math.ceil((new Date(endDate).getTime() - new Date(startDate).getTime()) / (1000 * 3600 * 24));
    const basePrice = car.price * days;
    const servicePrices = additionalServices.reduce((total: number, service: string) => {
      const prices: { [key: string]: number } = {
        gps: 10,
        insurance: 25,
        'child-seat': 15,
        driver: 20,
        wifi: 8,
      };
      return total + (prices[service] || 0);
    }, 0);
    const totalAmount = basePrice + servicePrices * days;

    const booking = new Booking({
      userId: req.user?.userId,
      carId,
      ownerId: car.ownerId,
      startDate,
      endDate,
      totalAmount,
      status: 'pending',
      pickupLocation,
      dropoffLocation,
      additionalServices,
      paymentMethod,
    });

    // Save booking and update car availability in a transaction
    const session = await Car.startSession();
    await session.withTransaction(async () => {
      await booking.save({ session });
      await Car.updateOne(
        { _id: carId },
        { $set: { available: false, updatedAt: new Date() } },
        { session }
      );
    });
    session.endSession();

    // Send notification email to owner
    const owner = await User.findById(car.ownerId).select('email name');
    if (owner) {
      await sendBookingStatusEmail({
        to: owner.email,
        userName: owner.name,
        carDetails: `${car.brand} ${car.carModel}`,
        status: 'pending',
        pickupLocation: booking.pickupLocation,
        startDate: booking.startDate,
      });
    }

    res.status(201).json(booking);
  } catch (error) {
    console.error('Create booking error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getBookings = async (req: AuthRequest, res: Response) => {
  try {
    const query = req.user?.role === 'admin' ? {} : { userId: req.user?.userId };
    const bookings = await Booking.find(query)
      .populate('userId', 'name email')
      .populate('carId', 'brand carModel ownerId');
    res.json(bookings);
  } catch (error) {
    console.error('Get bookings error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getPendingOwnerBookings = async (req: AuthRequest, res: Response) => {
  try {
    if (req.user?.role !== 'owner') {
      return res.status(403).json({ message: 'Access denied' });
    }
    const bookings = await Booking.find({ ownerId: req.user.userId, status: 'pending' })
      .populate('userId', 'name email')
      .populate('carId', 'brand carModel ownerId');
    res.json(bookings);
  } catch (error) {
    console.error('Get pending owner bookings error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getAllBookings = async (req: AuthRequest, res: Response) => {
  try {
    if (req.user?.role !== 'admin') {
      return res.status(403).json({ message: 'Access denied' });
    }
    const bookings = await Booking.find()
      .populate('userId', 'name email')
      .populate('carId', 'brand carModel ownerId');
    res.json(bookings);
  } catch (error) {
    console.error('Get all bookings error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const approveBooking = async (req: AuthRequest, res: Response) => {
  const { bookingId } = req.params;

  try {
    const booking = await Booking.findById(bookingId)
      .populate('userId', 'name email')
      .populate('carId', 'brand carModel ownerId');
    if (!booking) {
      return res.status(404).json({ message: 'Booking not found' });
    }

    if (req.user?.role !== 'owner' || booking.ownerId.toString() !== req.user?.userId) {
      return res.status(403).json({ message: 'Access denied' });
    }

    // Start a transaction to update booking and car atomically
    const session = await Booking.startSession();
    await session.withTransaction(async () => {
      booking.status = 'confirmed';
      booking.updatedAt = new Date();
      await booking.save({ session });

      // Update car availability to false
      await Car.updateOne(
        { _id: booking.carId },
        { $set: { available: false, updatedAt: new Date() } },
        { session }
      );
    });
    session.endSession();

    // Send approval email to customer
    const userEmail = (booking.userId as any).email;
    const userName = (booking.userId as any).name;
    const carDetails = `${(booking.carId as any).brand} ${(booking.carId as any).carModel}`;
    await sendBookingStatusEmail({
      to: userEmail,
      userName,
      carDetails,
      status: 'confirmed',
      pickupLocation: booking.pickupLocation,
      startDate: booking.startDate,
    });

    res.json({
      booking: {
        id: booking._id,
        userId: booking.userId,
        carId: booking.carId,
        ownerId: booking.ownerId,
        startDate: booking.startDate,
        endDate: booking.endDate,
        totalAmount: booking.totalAmount,
        status: booking.status,
        pickupLocation: booking.pickupLocation,
        dropoffLocation: booking.dropoffLocation,
        additionalServices: booking.additionalServices,
        paymentMethod: booking.paymentMethod,
        rejectionReason: booking.rejectionReason,
      },
    });
  } catch (error) {
    console.error('Approve booking error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const rejectBooking = async (req: AuthRequest, res: Response) => {
  const { bookingId } = req.params;
  const { rejectionReason } = req.body;

  try {
    const booking = await Booking.findById(bookingId)
      .populate('userId', 'name email')
      .populate('carId', 'brand carModel ownerId');
    if (!booking) {
      return res.status(404).json({ message: 'Booking not found' });
    }

    if (req.user?.role !== 'owner' || booking.ownerId.toString() !== req.user?.userId) {
      return res.status(403).json({ message: 'Access denied' });
    }

    booking.status = 'cancelled';
    booking.rejectionReason = rejectionReason || '';
    booking.updatedAt = new Date();
    await booking.save();

    // Set car back to available
    await Car.updateOne(
      { _id: booking.carId },
      { $set: { available: true, updatedAt: new Date() } }
    );

    // Send rejection email to customer
    const userEmail = (booking.userId as any).email;
    const userName = (booking.userId as any).name;
    const carDetails = `${(booking.carId as any).brand} ${(booking.carId as any).carModel}`;
    await sendBookingStatusEmail({
      to: userEmail,
      userName,
      carDetails,
      status: 'cancelled',
      pickupLocation: booking.pickupLocation,
      startDate: booking.startDate,
      rejectionReason,
    });

    res.json({
      booking: {
        id: booking._id,
        userId: booking.userId,
        carId: booking.carId,
        ownerId: booking.ownerId,
        startDate: booking.startDate,
        endDate: booking.endDate,
        totalAmount: booking.totalAmount,
        status: booking.status,
        pickupLocation: booking.pickupLocation,
        dropoffLocation: booking.dropoffLocation,
        additionalServices: booking.additionalServices,
        paymentMethod: booking.paymentMethod,
        rejectionReason: booking.rejectionReason,
      },
    });
  } catch (error) {
    console.error('Reject booking error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\controllers\carController.ts
import { Request, Response } from 'express';
import Car, { ICar } from '../models/Car';
import { AuthRequest } from '../middleware/authMiddleware';
import { validationResult } from 'express-validator';
import { sendCarStatusEmail } from '../services/emailService';
import path from 'path';
import fs from 'fs';
import { v2 as cloudinary } from 'cloudinary';
import multer from 'multer';
import mongoose from 'mongoose';

// Set up storage for uploaded files
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.join(__dirname, '../../Uploads');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, `${uniqueSuffix}-${file.originalname}`);
  },
});

// File filter to allow only images
const fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Only JPG and PNG images are allowed'));
  }
};

// Initialize Multer
export const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
});

// Optional: Configure Cloudinary (uncomment to use)
// cloudinary.config({
//   cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
//   api_key: process.env.CLOUDINARY_API_KEY,
//   api_secret: process.env.CLOUDINARY_API_SECRET,
// });

export const addCar = async (req: AuthRequest, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { brand, carModel, year, price, category, transmission, fuel, seats, features, wilaya, commune, chauffeur } = req.body;
  const file = req.file;

  if (!file) {
    return res.status(400).json({ message: 'Image file is required' });
  }

  try {
    console.log('Adding car with ownerId:', req.user?.userId); // Debug: Log ownerId
    const imagePath = `/Uploads/${file.filename}`;

    const car = new Car({
      brand,
      carModel,
      year: Number(year),
      price: Number(price),
      image: imagePath,
      category,
      transmission,
      fuel,
      seats: Number(seats),
      available: true,
      features: features ? JSON.parse(features) : [],
      wilaya,
      commune,
      rating: 0,
      ownerId: req.user?.userId,
      status: 'pending',
      chauffeur: chauffeur === 'true' || chauffeur === true,
    });

    await car.save();
    console.log('Car saved:', car); // Debug: Log saved car
    res.status(201).json({ car });
  } catch (error) {
    console.error('Add car error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getCars = async (req: Request, res: Response) => {
  try {
    const cars = await Car.find({ status: 'approved' }).populate('ownerId', 'name email');
    console.log('Fetched cars:', cars);
    res.json(cars);
  } catch (error) {
    console.error('Get cars error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getOwnerCars = async (req: AuthRequest, res: Response) => {
  try {
    console.log('Fetching cars for owner:', req.user?.userId); // Debug: Log userId
    const cars = await Car.find({ ownerId: req.user?.userId });
    console.log('Fetched owner cars:', cars);
    res.json(cars);
  } catch (error) {
    console.error('Get owner cars error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getPendingCars = async (req: AuthRequest, res: Response) => {
  try {
    const cars = await Car.find({ status: 'pending' }).populate('ownerId', 'name email');
    res.json(cars);
  } catch (error) {
    console.error('Get pending cars error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const approveCar = async (req: AuthRequest, res: Response) => {
  const { carId } = req.params;

  try {
    const car = await Car.findById(carId).populate('ownerId', 'name email');
    if (!car) {
      return res.status(404).json({ message: 'Car not found' });
    }

    car.status = 'approved';
    car.updatedAt = new Date();
    await car.save();

    const ownerEmail = (car.ownerId as any).email;
    const ownerName = (car.ownerId as any).name;
    await sendCarStatusEmail({
      to: ownerEmail,
      ownerName,
      carDetails: `${car.brand} ${car.carModel} (${car.year})`,
      status: 'approved',
      chauffeur: car.chauffeur,
    });

    res.json({
      car: {
        id: car._id,
        brand: car.brand,
        carModel: car.carModel,
        year: car.year,
        price: car.price,
        image: car.image,
        category: car.category,
        transmission: car.transmission,
        fuel: car.fuel,
        seats: car.seats,
        available: car.available,
        features: car.features,
        wilaya: car.wilaya,
        commune: car.commune,
        rating: car.rating,
        ownerId: car.ownerId,
        status: car.status,
        chauffeur: car.chauffeur,
      },
    });
  } catch (error) {
    console.error('Approve car error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const rejectCar = async (req: AuthRequest, res: Response) => {
  const { carId } = req.params;
  const { rejectionReason, definitive } = req.body;

  try {
    const car = await Car.findById(carId).populate('ownerId', 'name email');
    if (!car) {
      return res.status(404).json({ message: 'Car not found' });
    }

    car.status = 'rejected';
    car.rejectionReason = rejectionReason || (definitive ? 'Permanently rejected' : undefined);
    car.updatedAt = new Date();
    await car.save();

    const ownerEmail = (car.ownerId as any).email;
    const ownerName = (car.ownerId as any).name;
    await sendCarStatusEmail({
      to: ownerEmail,
      ownerName,
      carDetails: `${car.brand} ${car.carModel} (${car.year})`,
      status: 'rejected',
      rejectionReason: car.rejectionReason,
      chauffeur: car.chauffeur,
    });

    res.json({
      car: {
        id: car._id,
        brand: car.brand,
        carModel: car.carModel,
        year: car.year,
        price: car.price,
        image: car.image,
        category: car.category,
        transmission: car.transmission,
        fuel: car.fuel,
        seats: car.seats,
        available: car.available,
        features: car.features,
        wilaya: car.wilaya,
        commune: car.commune,
        rating: car.rating,
        ownerId: car.ownerId,
        status: car.status,
        rejectionReason: car.rejectionReason,
        chauffeur: car.chauffeur,
      },
    });
  } catch (error) {
    console.error('Reject car error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const editCar = async (req: AuthRequest, res: Response) => {
  const { carId } = req.params;
  const { brand, carModel, year, price, category, transmission, fuel, seats, features, wilaya, commune, chauffeur } = req.body;
  const file = req.file;

  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    // Fetch car WITHOUT populate initially
    const car = await Car.findById(carId);
    if (!car) {
      return res.status(404).json({ message: 'Car not found' });
    }

    console.log('Editing car:', { carId, ownerId: car.ownerId.toString(), userId: req.user?.userId, carStatus: car.status }); // Debug: Log ownership and status

    if (!req.user?.userId) {
      console.log('No userId in request');
      return res.status(401).json({ message: 'Authentication token is missing or invalid' });
    }

    // Use car.ownerId (ObjectId) for comparison
    if (car.ownerId.toString() !== req.user.userId) {
      console.log('Unauthorized: Owner ID mismatch', { carOwnerId: car.ownerId.toString(), userId: req.user.userId });
      return res.status(403).json({ message: 'Unauthorized to edit this car' });
    }

    if (car.status !== 'rejected' && car.status !== 'pending') {
      console.log('Invalid status for editing:', car.status);
      return res.status(400).json({ message: 'Can only edit rejected or pending cars' });
    }

    let imagePath = car.image;
    if (file) {
      imagePath = `/Uploads/${file.filename}`;
      if (car.image && car.image.startsWith('/Uploads/')) {
        const oldImagePath = path.join(__dirname, '../../', car.image);
        if (fs.existsSync(oldImagePath)) {
          fs.unlinkSync(oldImagePath);
        }
      }
    }

    car.brand = brand;
    car.carModel = carModel;
    car.year = Number(year);
    car.price = Number(price);
    car.image = imagePath;
    car.category = category;
    car.transmission = transmission;
    car.fuel = fuel;
    car.seats = Number(seats);
    car.features = features ? JSON.parse(features) : [];
    car.wilaya = wilaya;
    car.commune = commune;
    car.status = 'pending';
    car.rejectionReason = undefined;
    car.updatedAt = new Date();
    car.chauffeur = chauffeur === 'true' || chauffeur === true;

    await car.save();

    // Now populate for email sending
    await car.populate('ownerId', 'name email');

    const ownerEmail = (car.ownerId as any).email;
    const ownerName = (car.ownerId as any).name;
    await sendCarStatusEmail({
      to: ownerEmail,
      ownerName,
      carDetails: `${car.brand} ${car.carModel} (${car.year})`,
      status: 'resubmitted',
      chauffeur: car.chauffeur,
    });

    // Depopulate if needed for response, or just send as is (frontend likely doesn't care)
    res.json({ car });
  } catch (error) {
    console.error('Edit car error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Delete cars by IDs (admin-only)
export const deleteCarsById = async (req: AuthRequest, res: Response) => {
  const { ids } = req.body;

  // Validate input
  if (!ids || !Array.isArray(ids) || ids.length === 0) {
    return res.status(400).json({ message: 'An array of car IDs is required' });
  }

  try {
    // Check if user is admin
    if (!req.user || req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Only admins can delete cars' });
    }

    // Validate that all IDs are valid ObjectIds
    const validIds = ids.filter(id => mongoose.Types.ObjectId.isValid(id));
    if (validIds.length !== ids.length) {
      return res.status(400).json({ message: 'One or more invalid car IDs provided' });
    }

    // Find cars to delete (to clean up images)
    const cars = await Car.find({ _id: { $in: validIds } });

    // Delete associated images from file system
    for (const car of cars) {
      if (car.image && car.image.startsWith('/Uploads/')) {
        const imagePath = path.join(__dirname, '../../', car.image);
        if (fs.existsSync(imagePath)) {
          fs.unlinkSync(imagePath);
        }
      }
    }

    // Delete cars from database
    const result = await Car.deleteMany({ _id: { $in: validIds } });

    // Check if any cars were deleted
    if (result.deletedCount === 0) {
      return res.status(404).json({ message: 'No cars found with the provided IDs' });
    }

    res.json({
      message: 'Cars deleted successfully',
      deletedCount: result.deletedCount,
      deletedIds: validIds,
    });
  } catch (error) {
    console.error('Delete cars by ID error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Get a single car by ID
export const getCarById = async (req: Request, res: Response) => {
  const { carId } = req.params;

  try {
    const car = await Car.findById(carId).populate('ownerId', 'name email');
    if (!car) {
      return res.status(404).json({ message: 'Car not found' });
    }
    if (car.status !== 'approved') {
      return res.status(403).json({ message: 'Car is not available for booking' });
    }
    res.json(car);
  } catch (error) {
    console.error('Get car by ID error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

// Toggle car availability
export const toggleCarAvailability = async (req: AuthRequest, res: Response) => {
  const { carId } = req.params;
  const { available } = req.body;

  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    // Find the car to verify ownership and status
    const car = await Car.findById(carId);
    if (!car) {
      return res.status(404).json({ message: 'Car not found' });
    }

    if (!req.user?.userId) {
      return res.status(401).json({ message: 'Authentication token is missing or invalid' });
    }

    if (car.ownerId.toString() !== req.user.userId) {
      return res.status(403).json({ message: 'Unauthorized to modify this car' });
    }

    if (car.status !== 'approved') {
      return res.status(400).json({ message: 'Can only toggle availability for approved cars' });
    }

    // Update only the 'available' field and 'updatedAt' timestamp
    const result = await Car.updateOne(
      { _id: carId },
      { $set: { available: available, updatedAt: new Date() } }
    );

    if (result.matchedCount === 0) {
      return res.status(404).json({ message: 'Car not found' });
    }

    if (result.modifiedCount === 0) {
      return res.status(400).json({ message: 'No changes made to car availability' });
    }

    // Fetch the updated car for response
    const updatedCar = await Car.findById(carId).populate('ownerId', 'name email');

    res.json({
      message: `Car ${available ? 'made available' : 'made unavailable'} successfully`,
      car: {
        id: updatedCar?._id,
        brand: updatedCar?.brand,
        carModel: updatedCar?.carModel,
        year: updatedCar?.year,
        price: updatedCar?.price,
        image: updatedCar?.image,
        category: updatedCar?.category,
        transmission: updatedCar?.transmission,
        fuel: updatedCar?.fuel,
        seats: updatedCar?.seats,
        available: updatedCar?.available,
        features: updatedCar?.features,
        wilaya: updatedCar?.wilaya,
        commune: updatedCar?.commune,
        rating: updatedCar?.rating,
        ownerId: updatedCar?.ownerId,
        status: updatedCar?.status,
        rejectionReason: updatedCar?.rejectionReason,
        createdAt: updatedCar?.createdAt,
        updatedAt: updatedCar?.updatedAt,
        chauffeur: updatedCar?.chauffeur,
      },
    });
  } catch (error) {
    console.error('Toggle car availability error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\controllers\testimonialController.ts
import { Request, Response } from 'express';
import Testimonial, { ITestimonial } from '../models/Testimonial';
import { AuthRequest } from '../middleware/authMiddleware';
import { validationResult } from 'express-validator';

export const addTestimonial = async (req: AuthRequest, res: Response) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { name, location, rating, comment, avatar } = req.body;

  try {
    const testimonial = new Testimonial({
      name,
      location,
      rating,
      comment,
      avatar,
      userId: req.user?.userId
    });

    await testimonial.save();
    res.status(201).json(testimonial);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};

export const getTestimonials = async (req: Request, res: Response) => {
  try {
    const testimonials = await Testimonial.find().populate('userId', 'name email');
    res.json(testimonials);
  } catch (error) {
    res.status(500).json({ message: 'Server error' });
  }
};







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\controllers\userController.ts
import { Request, Response } from 'express';
import User from '../models/User';
import { AuthRequest } from '../middleware/authMiddleware';
import { sendOwnerApprovalEmail, sendDeclineUserEmail } from '../services/emailService'; // Added sendDeclineUserEmail

export const approveOwner = async (req: AuthRequest, res: Response) => {
  const { userId } = req.params;

  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    if (user.role !== 'owner') {
      return res.status(400).json({ message: 'User is not an owner' });
    }

    user.status = 'active';
    user.updatedAt = new Date();
    await user.save();

    // Send approval email
    await sendOwnerApprovalEmail({ to: user.email, userName: user.name });

    res.json({
      message: 'Owner approved',
      user: { id: user._id, name: user.name, email: user.email, status: user.status },
    });
  } catch (error) {
    console.error('Approve owner error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const declineUser = async (req: AuthRequest, res: Response) => {
  const { userId } = req.params;

  try {
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }

    // Send decline email before deletion
    await sendDeclineUserEmail({ to: user.email, userName: user.name });

    // Delete the user
    await User.deleteOne({ _id: userId });

    res.json({ message: 'User declined and deleted' });
  } catch (error) {
    console.error('Decline user error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};

export const getUsers = async (req: AuthRequest, res: Response) => {
  try {
    const users = await User.find().select('-password -__v');
    res.json(users);
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ message: 'Server error' });
  }
};









// [Folder] middleware








// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\middleware\authMiddleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

// Explicitly export the AuthRequest interface
export interface AuthRequest extends Request {
  user?: { userId: string; role: string };
}

export const authMiddleware = (req: AuthRequest, res: Response, next: NextFunction) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    console.log('No token provided in request', { url: req.url, method: req.method });
    return res.status(401).json({ message: 'No token provided' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET as string) as { userId: string; role: string };
    console.log('Decoded token:', { userId: decoded.userId, role: decoded.role, url: req.url });
    req.user = decoded;
    next();
  } catch (error) {
    console.error('Token verification error:', { error, tokenSnippet: token.slice(0, 10) + '...' });
    res.status(401).json({ message: 'Invalid token' });
  }
};

export const roleMiddleware = (roles: string[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      console.log('Role check failed:', { userRole: req.user?.role, requiredRoles: roles, url: req.url });
      return res.status(403).json({ message: 'Access denied' });
    }
    console.log('Role check passed:', { userRole: req.user.role, url: req.url });
    next();
  };
};











// [Folder] models








// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\models\Booking.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IBooking extends Document {
  userId: mongoose.Types.ObjectId;
  carId: mongoose.Types.ObjectId;
  ownerId: mongoose.Types.ObjectId; // Added
  startDate: Date;
  endDate: Date;
  totalAmount: number;
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled';
  pickupLocation: string;
  dropoffLocation: string;
  additionalServices: string[];
  paymentMethod: 'credit-card' | 'paypal';
  rejectionReason?: string; // Added
  createdAt: Date;
  updatedAt: Date;
}

const BookingSchema: Schema = new Schema({
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  carId: { type: Schema.Types.ObjectId, ref: 'Car', required: true },
  ownerId: { type: Schema.Types.ObjectId, ref: 'User', required: true }, // Added
  startDate: { type: Date, required: true },
  endDate: { type: Date, required: true },
  totalAmount: { type: Number, required: true },
  status: { type: String, enum: ['pending', 'confirmed', 'completed', 'cancelled'], default: 'pending' },
  pickupLocation: { type: String, required: true },
  dropoffLocation: { type: String, required: true },
  additionalServices: [{ type: String }],
  paymentMethod: { type: String, enum: ['credit-card', 'paypal'], required: true },
  rejectionReason: { type: String }, // Added
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model<IBooking>('Booking', BookingSchema);







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\models\Car.ts
import { Schema, Document, Types, model } from 'mongoose';

export interface ICar extends Document {
  brand: string;
  carModel: string;
  year: number;
  price: number;
  image: string;
  category: 'Economy' | 'Compact' | 'SUV' | 'Luxury' | 'Sports';
  transmission: 'Manual' | 'Automatic';
  fuel: 'Petrol' | 'Diesel' | 'Electric' | 'Hybrid';
  seats: number;
  available: boolean;
  features: string[];
  wilaya: string;  // New: Selected wilaya name
  commune: string; // New: Selected commune name
  rating: number;
  ownerId: Types.ObjectId;
  status: 'pending' | 'approved' | 'rejected';
  rejectionReason?: string;
  createdAt: Date;
  updatedAt: Date;
  chauffeur: boolean;
}

const CarSchema: Schema<ICar> = new Schema({
  brand: { type: String, required: true },
  carModel: { type: String, required: true },
  year: { type: Number, required: true },
  price: { type: Number, required: true },
  image: { type: String, required: true },
  category: { type: String, enum: ['Economy', 'Compact', 'SUV', 'Luxury', 'Sports'], required: true },
  transmission: { type: String, enum: ['Manual', 'Automatic'], required: true },
  fuel: { type: String, enum: ['Petrol', 'Diesel', 'Electric', 'Hybrid'], required: true },
  seats: { type: Number, required: true },
  available: { type: Boolean, default: true },
  features: [{ type: String }],
  wilaya: { type: String, required: true },  // New
  commune: { type: String, required: true }, // New
  rating: { type: Number, default: 0 },
  ownerId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  status: { type: String, enum: ['pending', 'approved', 'rejected'], default: 'pending' },
  rejectionReason: { type: String, required: false },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
  chauffeur: { type: Boolean, default: false },
});

export default model<ICar>('Car', CarSchema);







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\models\Testimonial.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface ITestimonial extends Document {
  name: string;
  location: string;
  rating: number;
  comment: string;
  avatar: string;
  userId: mongoose.Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const TestimonialSchema: Schema = new Schema({
  name: { type: String, required: true },
  location: { type: String, required: true },
  rating: { type: Number, required: true, min: 1, max: 5 },
  comment: { type: String, required: true },
  avatar: { type: String, required: true },
  userId: { type: Schema.Types.ObjectId, ref: 'User', required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model<ITestimonial>('Testimonial', TestimonialSchema);







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\models\User.ts
import mongoose, { Schema, Document } from 'mongoose';

export interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  phone: string;
  role: 'customer' | 'admin' | 'owner';
  joinDate: Date;
  status: 'active' | 'inactive' | 'pending';
  createdAt: Date;
  updatedAt: Date;
}

const UserSchema: Schema = new Schema({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  phone: { type: String, required: true },
  role: { type: String, enum: ['customer', 'admin', 'owner'], required: true },
  joinDate: { type: Date, default: Date.now },
  status: { type: String, enum: ['active', 'inactive', 'pending'], default: 'active' },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

export default mongoose.model<IUser>('User', UserSchema);









// [Folder] routes








// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\routes\authRoutes.ts
import { Router } from 'express';
import { register, login } from '../controllers/authController';
import { check } from 'express-validator';

const router = Router();

router.post(
  '/register',
  [
    check('name', 'Name is required').not().isEmpty(),
    check('email', 'Please include a valid email').isEmail(),
    check('password', 'Password must be at least 6 characters').isLength({ min: 6 }),
    check('phone', 'Phone number is required').not().isEmpty(),
    check('role', 'Invalid role').isIn(['customer', 'owner'])
  ],
  register
);

router.post(
  '/login',
  [
    check('email', 'Please include a valid email').isEmail(),
    check('password', 'Password is required').exists()
  ],
  login
);

export default router;







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\routes\bookingRoutes.ts
import { Router } from 'express';
import { createBooking, getBookings, getPendingOwnerBookings, getAllBookings, approveBooking, rejectBooking } from '../controllers/bookingController';
import { authMiddleware, roleMiddleware } from '../middleware/authMiddleware';
import { check } from 'express-validator';

const router = Router();

router.post(
  '/',
  [
    authMiddleware,
    roleMiddleware(['customer']),
    check('carId', 'Car ID is required').not().isEmpty(),
    check('startDate', 'Start date is required').isISO8601(),
    check('endDate', 'End date is required').isISO8601(),
    check('pickupLocation', 'Pickup location is required').not().isEmpty(),
    check('dropoffLocation', 'Dropoff location is required').not().isEmpty(),
    check('paymentMethod', 'Invalid payment method').isIn(['credit-card', 'paypal'])
  ],
  createBooking
);

router.get('/', authMiddleware, roleMiddleware(['customer', 'admin']), getBookings);
router.get('/pending/owner', authMiddleware, roleMiddleware(['owner']), getPendingOwnerBookings);
router.get('/all', authMiddleware, roleMiddleware(['admin']), getAllBookings);
router.put('/approve/:bookingId', authMiddleware, roleMiddleware(['owner']), approveBooking);
router.put('/reject/:bookingId', authMiddleware, roleMiddleware(['owner']), rejectBooking);

export default router;







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\routes\carRoutes.ts
// C:\Users\kebic\OneDrive\Desktop\car_rent_rahim\car_rent_backend\routes\carRoutes.ts
import { Router } from 'express';
import {
  addCar,
  getCars,
  getOwnerCars,
  getPendingCars,
  approveCar,
  rejectCar,
  editCar,
  upload,
  deleteCarsById,
  getCarById, // New
  toggleCarAvailability, // New
} from '../controllers/carController';
import { authMiddleware, roleMiddleware } from '../middleware/authMiddleware';
import { check } from 'express-validator';

const router = Router();

router.post(
  '/',
  [
    authMiddleware,
    roleMiddleware(['owner']),
    upload.single('image'),
    check('brand', 'Brand is required').not().isEmpty(),
    check('carModel', 'Model is required').not().isEmpty(),
    check('year', 'Year must be a number').isNumeric(),
    check('price', 'Price must be a number').isNumeric(),
    check('category', 'Invalid category').isIn(['Economy', 'Compact', 'SUV', 'Luxury', 'Sports']),
    check('transmission', 'Invalid transmission').isIn(['Manual', 'Automatic']),
    check('fuel', 'Invalid fuel type').isIn(['Petrol', 'Diesel', 'Electric', 'Hybrid']),
    check('seats', 'Seats must be a number').isNumeric(),
    check('wilaya', 'Wilaya is required').not().isEmpty(),
    check('commune', 'Commune is required').not().isEmpty(),
    check('chauffeur', 'Chauffeur must be a boolean').isBoolean(),
  ],
  addCar
);

router.put(
  '/edit/:carId',
  [
    authMiddleware,
    roleMiddleware(['owner']),
    upload.single('image'),
    check('brand', 'Brand is required').not().isEmpty(),
    check('carModel', 'Model is required').not().isEmpty(),
    check('year', 'Year must be a number').isNumeric(),
    check('price', 'Price must be a number').isNumeric(),
    check('category', 'Invalid category').isIn(['Economy', 'Compact', 'SUV', 'Luxury', 'Sports']),
    check('transmission', 'Invalid transmission').isIn(['Manual', 'Automatic']),
    check('fuel', 'Invalid fuel type').isIn(['Petrol', 'Diesel', 'Electric', 'Hybrid']),
    check('seats', 'Seats must be a number').isNumeric(),
    check('wilaya', 'Wilaya is required').not().isEmpty(),
    check('commune', 'Commune is required').not().isEmpty(),
    check('chauffeur', 'Chauffeur must be a boolean').isBoolean(),
  ],
  editCar
);

router.get('/', getCars);
router.get('/owner', authMiddleware, roleMiddleware(['owner']), getOwnerCars);
router.get('/pending', authMiddleware, roleMiddleware(['admin']), getPendingCars);
router.get('/:carId', getCarById); // New: Fetch single car
router.put(
  '/toggle-availability/:carId', // New: Toggle availability
  [
    authMiddleware,
    roleMiddleware(['owner']),
    check('available', 'Availability must be a boolean').isBoolean(),
  ],
  toggleCarAvailability
);
router.put('/approve/:carId', authMiddleware, roleMiddleware(['admin']), approveCar);
router.put('/reject/:carId', authMiddleware, roleMiddleware(['admin']), rejectCar);
router.post(
  '/delete-by-ids',
  [
    authMiddleware,
    roleMiddleware(['admin']),
    check('ids', 'An array of car IDs is required').isArray({ min: 1 }),
  ],
  deleteCarsById
);

export default router;







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\routes\testimonialRoutes.ts
import { Router } from 'express';
import { addTestimonial, getTestimonials } from '../controllers/testimonialController';
import { authMiddleware, roleMiddleware } from '../middleware/authMiddleware';
import { check } from 'express-validator';

const router = Router();

router.post(
  '/',
  [
    authMiddleware,
    roleMiddleware(['customer']),
    check('name', 'Name is required').not().isEmpty(),
    check('location', 'Location is required').not().isEmpty(),
    check('rating', 'Rating must be between 1 and 5').isInt({ min: 1, max: 5 }),
    check('comment', 'Comment is required').not().isEmpty(),
    check('avatar', 'Avatar URL is required').not().isEmpty()
  ],
  addTestimonial
);

router.get('/', getTestimonials);

export default router;







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\routes\userRoutes.ts
import { Router } from 'express';
import { approveOwner, getUsers, declineUser } from '../controllers/userController';
import { authMiddleware, roleMiddleware } from '../middleware/authMiddleware';

const router = Router();

// Get all users (admin only)
router.get('/', authMiddleware, roleMiddleware(['admin']), getUsers);

// Approve an owner (admin only)
router.put('/approve/:userId', authMiddleware, roleMiddleware(['admin']), approveOwner);

// Decline and delete a user (admin only)
router.delete('/decline/:userId', authMiddleware, roleMiddleware(['admin']), declineUser);

export default router;









// [Folder] scripts








// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\scripts\extract_code.js
import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Go up one level to the main module directory
const sourceFolder = path.resolve(__dirname, '..');
const outputFile = path.join(__dirname, 'car_code_output.txt');
const extensions = ['.py', '.xml', '.csv', '.js', '.css', '.tsx', '.ts', 'jsx']; // Added .tsx for About.tsx

function concatenateFiles(folderPath, depth = 0) {
  const files = fs.readdirSync(folderPath);
  let fileContent = '';
  let folderContent = '';

  files.forEach(file => {
    const filePath = path.join(folderPath, file);
    const stats = fs.statSync(filePath);

    if (stats.isDirectory()) {
      const subContent = concatenateFiles(filePath, depth + 1);
      if (subContent && subContent.trim()) {
        folderContent += `\n\n\n\n\n\n\n\n// ${'  '.repeat(depth)}[Folder] ${file}\n${subContent}\n\n`;
      }
    } else {
      for (const ext of extensions) {
        if (file.endsWith(ext)) {
          const fileData = fs.readFileSync(filePath, 'utf-8');
          fileContent += `\n\n\n\n\n\n\n\n// ${filePath}\n${fileData}`;
          break;
        }
      }
    }
  });

  return folderContent + fileContent;
}

// Start with a clean output file
fs.writeFileSync(outputFile, '', 'utf-8');
const allContent = concatenateFiles(sourceFolder);
fs.appendFileSync(outputFile, allContent, 'utf-8');

console.log(`✅ Code extracted to: ${outputFile}`);










// [Folder] services








// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\services\emailService.ts
import nodemailer from 'nodemailer';
import dotenv from 'dotenv';

dotenv.config();

const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_HOST,
  port: Number(process.env.EMAIL_PORT),
  secure: false, // Use TLS
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

interface CarEmailOptions {
  to: string;
  ownerName: string;
  carDetails: string;
  status: 'approved' | 'rejected' | 'resubmitted';
  rejectionReason?: string;
  chauffeur?: boolean;
}

interface BookingEmailOptions {
  to: string;
  userName: string;
  carDetails: string;
  status: 'pending' | 'confirmed' | 'cancelled';
  pickupLocation: string;
  startDate: Date;
  rejectionReason?: string;
}

interface RegistrationPendingEmailOptions {
  to: string;
  userName: string;
}

interface OwnerApprovalEmailOptions {
  to: string;
  userName: string;
}

interface DeclineUserEmailOptions {
  to: string;
  userName: string;
}

export const sendCarStatusEmail = async ({ to, ownerName, carDetails, status, rejectionReason, chauffeur }: CarEmailOptions) => {
  let subject: string;
  let html: string;

  switch (status) {
    case 'approved':
      subject = `Your Car ${carDetails} Has Been Approved!`;
      html = `
        <h2>Hello ${ownerName},</h2>
        <p>We are pleased to inform you that your car, <strong>${carDetails}</strong>, has been approved by our admin team.</p>
        <p>It is now available for booking on our platform${chauffeur ? ' with chauffeur service' : ''}. You can view and manage your car in the Owner Panel.</p>
        <p>Thank you for listing with us!</p>
        <p>Best regards,<br>Your Car Rental Team</p>
      `;
      break;
    case 'rejected':
      subject = `Update on Your Car ${carDetails}`;
      html = `
        <h2>Hello ${ownerName},</h2>
        <p>We regret to inform you that your car, <strong>${carDetails}</strong>, has been rejected by our admin team.</p>
        ${rejectionReason ? `<p><strong>Reason:</strong> ${rejectionReason}</p>` : ''}
        <p>${rejectionReason !== 'Permanently rejected' ? 'You can edit and resubmit your car details in the Owner Panel to address the issue.' : 'This is a definitive rejection and the car cannot be resubmitted.'}</p>
        <p>Please contact us if you have any questions.</p>
        <p>Best regards,<br>Your Car Rental Team</p>
      `;
      break;
    case 'resubmitted':
      subject = `Your Car ${carDetails} Has Been Resubmitted`;
      html = `
        <h2>Hello ${ownerName},</h2>
        <p>Your car, <strong>${carDetails}</strong>, has been successfully resubmitted for admin review${chauffeur ? ' with chauffeur service' : ''}.</p>
        <p>We will notify you once the admin team reviews your updated submission.</p>
        <p>Thank you for your patience!</p>
        <p>Best regards,<br>Your Car Rental Team</p>
      `;
      break;
    default:
      throw new Error('Invalid status');
  }

  try {
    await transporter.sendMail({
      from: `"Car Rental Platform" <${process.env.EMAIL_USER}>`,
      to,
      subject,
      html,
    });
    console.log(`Email sent to ${to} for car ${carDetails} with status ${status}`);
  } catch (error) {
    console.error('Error sending email:', error);
    throw new Error('Failed to send email');
  }
};

export const sendBookingStatusEmail = async ({ to, userName, carDetails, status, pickupLocation, startDate, rejectionReason }: BookingEmailOptions) => {
  let subject: string;
  let html: string;

  switch (status) {
    case 'pending':
      subject = `New Booking Request for ${carDetails}`;
      html = `
        <h2>Hello ${userName},</h2>
        <p>A new booking request has been made for your car: <strong>${carDetails}</strong>.</p>
        <p><strong>Details:</strong></p>
        <ul>
          <li>Pickup Location: ${pickupLocation}</li>
          <li>Pickup Date: ${new Date(startDate).toLocaleDateString()}</li>
        </ul>
        <p>Please review the booking in your Owner Panel and approve or reject it.</p>
        <p>Best regards,<br>Your Car Rental Team</p>
      `;
      break;
    case 'confirmed':
      subject = `Your Booking for ${carDetails} Has Been Confirmed!`;
      html = `
        <h2>Hello ${userName},</h2>
        <p>We are pleased to confirm your booking for <strong>${carDetails}</strong>.</p>
        <p><strong>Details:</strong></p>
        <ul>
          <li>Pickup Location: ${pickupLocation}</li>
          <li>Pickup Date: ${new Date(startDate).toLocaleDateString()}</li>
        </ul>
        <p>Please visit our location at the specified time to collect your vehicle. If you have any questions, feel free to contact us.</p>
        <p>Thank you for choosing our service!</p>
        <p>Best regards,<br>Your Car Rental Team</p>
      `;
      break;
    case 'cancelled':
      subject = `Update on Your Booking for ${carDetails}`;
      html = `
        <h2>Hello ${userName},</h2>
        <p>We regret to inform you that your booking for <strong>${carDetails}</strong> has been cancelled.</p>
        ${rejectionReason ? `<p><strong>Reason:</strong> ${rejectionReason}</p>` : ''}
        <p>Please contact us if you have any questions or would like to make another booking.</p>
        <p>Best regards,<br>Your Car Rental Team</p>
      `;
      break;
    default:
      throw new Error('Invalid status');
  }

  try {
    await transporter.sendMail({
      from: `"Car Rental Platform" <${process.env.EMAIL_USER}>`,
      to,
      subject,
      html,
    });
    console.log(`Booking email sent to ${to} for ${carDetails} with status ${status}`);
  } catch (error) {
    console.error('Error sending booking email:', error);
    throw new Error('Failed to send booking email');
  }
};

export const sendRegistrationPendingEmail = async ({ to, userName }: RegistrationPendingEmailOptions) => {
  const subject = 'Your Registration is Under Review';
  const html = `
    <h2>Hello ${userName},</h2>
    <p>Thank you for registering as an owner on our Car Rental Platform.</p>
    <p>Your registration is currently under review. Our admin team will contact you as soon as possible to discuss or set up a meeting to verify your documents.</p>
    <p>You will receive another email once your account is approved.</p>
    <p>If you have any questions, please contact our support team.</p>
    <p>Best regards,<br>Your Car Rental Team</p>
  `;

  try {
    await transporter.sendMail({
      from: `"Car Rental Platform" <${process.env.EMAIL_USER}>`,
      to,
      subject,
      html,
    });
    console.log(`Registration pending email sent to ${to}`);
  } catch (error) {
    console.error('Error sending registration pending email:', error);
    throw new Error('Failed to send registration pending email');
  }
};

export const sendOwnerApprovalEmail = async ({ to, userName }: OwnerApprovalEmailOptions) => {
  const subject = 'Your Owner Account Has Been Approved!';
  const html = `
    <h2>Hello ${userName},</h2>
    <p>We are pleased to inform you that your owner account has been approved by our admin team.</p>
    <p>You can now log in to your account and start adding cars to our platform.</p>
    <p>Visit the Owner Panel to get started.</p>
    <p>Thank you for joining our platform!</p>
    <p>Best regards,<br>Your Car Rental Team</p>
  `;

  try {
    await transporter.sendMail({
      from: `"Car Rental Platform" <${process.env.EMAIL_USER}>`,
      to,
      subject,
      html,
    });
    console.log(`Owner approval email sent to ${to}`);
  } catch (error) {
    console.error('Error sending owner approval email:', error);
    throw new Error('Failed to send owner approval email');
  }
};

export const sendDeclineUserEmail = async ({ to, userName }: DeclineUserEmailOptions) => {
  const subject = 'Your Registration Has Been Declined';
  const html = `
    <h2>Hello ${userName},</h2>
    <p>We regret to inform you that your registration on our Car Rental Platform has been declined.</p>
    <p>If you believe this is an error or have any questions, please contact our support team.</p>
    <p>Thank you for your interest in our platform.</p>
    <p>Best regards,<br>Your Car Rental Platform Team</p>
  `;

  try {
    await transporter.sendMail({
      from: `"Car Rental Platform" <${process.env.EMAIL_USER}>`,
      to,
      subject,
      html,
    });
    console.log(`Decline email sent to ${to}`);
  } catch (error) {
    console.error('Error sending decline email:', error);
    throw new Error('Failed to send decline email');
  }
};









// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\app.ts
import express, { Application } from 'express';
import path from 'path';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import authRoutes from './routes/authRoutes';
import carRoutes from './routes/carRoutes';
import bookingRoutes from './routes/bookingRoutes';
import testimonialRoutes from './routes/testimonialRoutes';
import userRoutes from './routes/userRoutes';
import cors from 'cors';

dotenv.config();

const app: Application = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(express.json());
app.use(cors());

app.use('/uploads', express.static(path.join(__dirname, '../Uploads')));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/cars', carRoutes);
app.use('/api/bookings', bookingRoutes);
app.use('/api/testimonials', testimonialRoutes);
app.use('/api/users', userRoutes);

// MongoDB Connection
mongoose.connect(process.env.MONGODB_URI as string)
  .then(() => console.log('Connected to MongoDB'))
  .catch((err) => console.error('MongoDB connection error:', err));

// Start Server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});







// C:\Users\kebic\OneDrive\Desktop\projects\car_rent_rahim\car_rent_backend\src\seed.ts
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import dotenv from 'dotenv';
import User from './models/User';
import Car from './models/Car';
import Booking from './models/Booking';
import Testimonial from './models/Testimonial';

dotenv.config();

async function seedDatabase() {
  try {
    await mongoose.connect(process.env.MONGODB_URI as string);
    console.log('Connected to MongoDB');

    // Clear existing data (optional, comment out to keep existing data)
    await User.deleteMany({});
    await Car.deleteMany({});
    await Booking.deleteMany({});
    await Testimonial.deleteMany({});
    console.log('Cleared existing data');

    // Insert users
    const hashedPassword = await bcrypt.hash('password123', 10);
    const users = await User.insertMany([
      {
        name: 'John Doe',
        email: 'john@example.com',
        password: hashedPassword,
        phone: '+1234567890',
        role: 'customer',
        status: 'active'
      },
      {
        name: 'Jane Owner',
        email: 'jane@example.com',
        password: hashedPassword,
        phone: '+1234567891',
        role: 'owner',
        status: 'active' // Active for testing
      },
      {
        name: 'Admin User',
        email: 'admin@example.com',
        password: hashedPassword,
        phone: '+1234567899',
        role: 'admin',
        status: 'active'
      }
    ]);
    console.log('Inserted users');

    // Find owner
    const owner = users.find((u: any) => u.role === 'owner');
    if (!owner) {
      throw new Error('No owner user found');
    }
    const ownerId = owner._id;

    // Insert cars
    const cars = await Car.insertMany([
      {
        brand: 'Toyota',
        carModel: 'Camry', // Updated to carModel
        year: 2023,
        price: 45,
        image: 'https://images.pexels.com/photos/116675/pexels-photo-116675.jpeg?auto=compress&cs=tinysrgb&w=500',
        category: 'Compact',
        transmission: 'Automatic',
        fuel: 'Petrol',
        seats: 5,
        available: true,
        features: ['GPS', 'AC', 'Bluetooth'],
        location: 'Downtown',
        rating: 4.5,
        ownerId: ownerId
      },
      {
        brand: 'BMW',
        carModel: 'X5', // Updated to carModel
        year: 2023,
        price: 95,
        image: 'https://images.pexels.com/photos/244206/pexels-photo-244206.jpeg?auto=compress&cs=tinysrgb&w=500',
        category: 'SUV',
        transmission: 'Automatic',
        fuel: 'Petrol',
        seats: 7,
        available: true,
        features: ['GPS', 'Leather Seats', 'Sunroof'],
        location: 'Airport',
        rating: 4.8,
        ownerId: ownerId
      }
    ]);
    console.log('Inserted cars');

    // Find customer
    const customer = users.find((u: any) => u.role === 'customer');
    if (!customer) {
      throw new Error('No customer user found');
    }
    const customerId = customer._id;

    // Insert bookings
    await Booking.insertMany([
      {
        userId: customerId,
        carId: cars[0]._id,
        startDate: new Date('2025-08-15'),
        endDate: new Date('2025-08-18'),
        totalAmount: 135,
        status: 'confirmed',
        pickupLocation: 'Downtown Office',
        dropoffLocation: 'Airport',
        additionalServices: ['gps', 'insurance'],
        paymentMethod: 'credit-card'
      }
    ]);
    console.log('Inserted bookings');

    // Insert testimonials
    await Testimonial.insertMany([
      {
        name: 'Emily Davis',
        location: 'New York, NY',
        rating: 5,
        comment: 'Excellent service!',
        avatar: 'https://images.pexels.com/photos/774909/pexels-photo-774909.jpeg?auto=compress&cs=tinysrgb&w=150',
        userId: customerId
      }
    ]);
    console.log('Inserted testimonials');

    console.log('Database seeded successfully!');
  } catch (error) {
    console.error('Error seeding database:', error);
  } finally {
    await mongoose.disconnect();
    console.log('Disconnected from MongoDB');
  }
}

seedDatabase();